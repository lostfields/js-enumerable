/* eslint-disable */
// @ts-nocheck 

let parser = /*
* Generated by PEG.js 0.10.0.
*
* http://pegjs.org/
*/
(function() {
 "use strict";

 function peg$subclass(child, parent) {
   function ctor() { this.constructor = child; }
   ctor.prototype = parent.prototype;
   child.prototype = new ctor();
 }

 function peg$SyntaxError(message, expected, found, location) {
   this.message  = message;
   this.expected = expected;
   this.found    = found;
   this.location = location;
   this.name     = "SyntaxError";

   if (typeof Error.captureStackTrace === "function") {
     Error.captureStackTrace(this, peg$SyntaxError);
   }
 }

 peg$subclass(peg$SyntaxError, Error);

 peg$SyntaxError.buildMessage = function(expected, found) {
   var DESCRIBE_EXPECTATION_FNS = {
         literal: function(expectation) {
           return "\"" + literalEscape(expectation.text) + "\"";
         },

         "class": function(expectation) {
           var escapedParts = "",
               i;

           for (i = 0; i < expectation.parts.length; i++) {
             escapedParts += expectation.parts[i] instanceof Array
               ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
               : classEscape(expectation.parts[i]);
           }

           return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
         },

         any: function(expectation) {
           return "any character";
         },

         end: function(expectation) {
           return "end of input";
         },

         other: function(expectation) {
           return expectation.description;
         }
       };

   function hex(ch) {
     return ch.charCodeAt(0).toString(16).toUpperCase();
   }

   function literalEscape(s) {
     return s
       .replace(/\\/g, '\\\\')
       .replace(/"/g,  '\\"')
       .replace(/\0/g, '\\0')
       .replace(/\t/g, '\\t')
       .replace(/\n/g, '\\n')
       .replace(/\r/g, '\\r')
       .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
       .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
   }

   function classEscape(s) {
     return s
       .replace(/\\/g, '\\\\')
       .replace(/\]/g, '\\]')
       .replace(/\^/g, '\\^')
       .replace(/-/g,  '\\-')
       .replace(/\0/g, '\\0')
       .replace(/\t/g, '\\t')
       .replace(/\n/g, '\\n')
       .replace(/\r/g, '\\r')
       .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
       .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
   }

   function describeExpectation(expectation) {
     return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
   }

   function describeExpected(expected) {
     var descriptions = new Array(expected.length),
         i, j;

     for (i = 0; i < expected.length; i++) {
       descriptions[i] = describeExpectation(expected[i]);
     }

     descriptions.sort();

     if (descriptions.length > 0) {
       for (i = 1, j = 1; i < descriptions.length; i++) {
         if (descriptions[i - 1] !== descriptions[i]) {
           descriptions[j] = descriptions[i];
           j++;
         }
       }
       descriptions.length = j;
     }

     switch (descriptions.length) {
       case 1:
         return descriptions[0];

       case 2:
         return descriptions[0] + " or " + descriptions[1];

       default:
         return descriptions.slice(0, -1).join(", ")
           + ", or "
           + descriptions[descriptions.length - 1];
     }
   }

   function describeFound(found) {
     return found ? "\"" + literalEscape(found) + "\"" : "end of input";
   }

   return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
 };

 function peg$parse(input, options?) {
   options = options !== void 0 ? options : {};

   var peg$FAILED = {},

       peg$startRuleIndices = { Start: 0 },
       peg$startRuleIndex   = 0,

       peg$consts = [
         function(args, expr) {
               return {
                   type: 'LambdaExpression',
                     arguments: [args],
                     expression: expr
                 }
             },
         function(expr) {
               return {
                   type: 'LambdaExpression',
                     arguments: [],
                     expression: expr
                 }
             },
         function(first, rest) { return buildList(first, rest, 1); },
         function(args, expr) {
               return {
                   type: 'LambdaExpression',
                     arguments: args,
                     expression: expr
                 }
             },
         function(test, left, right) {
               return { 
                   type: 'ConditionalExpression',
                     test: test,
                     left: left,
                     right: right
                 }
               },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'LogicalExpression',
                   operator: element[0][0].toLowerCase(),
                   left: result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'LogicalExpression',
                   operator: element[0][0].toLowerCase(),
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'BitwiseExpression',
                   operator: element[0][0].toLowerCase(),
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'RelationalExpression',
                   operator: element[0][0],
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'RelationalExpression',
                   operator: element[0][0].toLowerCase(),
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'ShiftExpression',
                   operator: element[0][0].toLowerCase(),
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'BinaryExpression',
                   operator: element[0][0].toLowerCase(),
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(operator, operand) { return operand.type === 'NumberLiteral' && (operator === '-' || operator === '+')
                 ? 
                 { 
                   type: 'NumberLiteral', 
                   value: (operator === '-' ? operator : '') + operand.value
                 }
                 :
                 (operator === '-' || operator === '+') && operand.type === 'PostfixExpression' && operand.argument.type === 'NumberLiteral'
                 ?
                 Object.assign(operand, {argument: { 
                   type: 'NumberLiteral',
                     value: (operator === '-' ? operator : '') + operand.argument.value
                 }})
                 :
                 {
                   type: 'UnaryExpression', 
                   operator: operator, 
                   argument:  operand
                 };
             },
         function(operand, operator) { return operator 
             ? 
                 {
                   type: 'PostfixExpression',
                     operator: operator,
                     argument: operand
                 }
                 :
                 operand
             },
         function(expr) { return expr; },
         function(qual, args) { 
               return {
                 type: 'CallExpression', 
                 object: qual,
                 arguments: args
               };
             },
         function(qual, expr) { 
               return { 
               type: 'ArrayExpression',
                 object: qual,
                 index: expr
               };
             },
         function(first, rest) {
                return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'MemberExpression',
                   object:  result,
                   property: element[1]
                 };
               });
             },
         function(op) { return op[0].toLowerCase(); },
         function(args) { return args || []; },
         function(exp) { return exp; },
         /^[ \t\r\n\f]/,
         peg$classExpectation([" ", "\t", "\r", "\n", "\f"], false, false),
         function(first, last) { return { type: 'Identifier', name: first + last.join('') }; },
         /^[a-z]/,
         peg$classExpectation([["a", "z"]], false, false),
         /^[A-Z]/,
         peg$classExpectation([["A", "Z"]], false, false),
         /^[_$]/,
         peg$classExpectation(["_", "$"], false, false),
         /^[0-9]/,
         peg$classExpectation([["0", "9"]], false, false),
         "`",
         peg$literalExpectation("`", false),
         "\\$",
         peg$literalExpectation("\\$", false),
         /^[{]/,
         peg$classExpectation(["{"], false, false),
         peg$anyExpectation(),
         "$",
         peg$literalExpectation("$", false),
         "\\${",
         peg$literalExpectation("\\${", false),
         "$\\{",
         peg$literalExpectation("$\\{", false),
         "\\$\\{",
         peg$literalExpectation("\\$\\{", false),
         /^[$`\\]/,
         peg$classExpectation(["$", "`", "\\"], false, false),
         function(capture) { return { 
                 type: 'TemplateLiteral', 
                 values: capture.reduce((r, v) => {
                     if(Array.isArray(v)) {
                       if(typeof(r[r.length - 1]) != 'string')
                           r.push('')  
                       r[r.length - 1] += v[0] == undefined ? v[1] : v[0] + (v[1] == undefined ? v[2] : v[1])
                     } else {
                       r.push(v);
                     }
                     return r;
                 }, []).map(v => typeof v == 'string' ? { type: 'Literal', value: v } : v )
               }
             },
         function(expression) { return {
               type: 'TemplateExpression',
                 value: expression
               }
             },
         "true",
         peg$literalExpectation("true", false),
         function() { return { type: 'BooleanLiteral', value: true }; },
         "false",
         peg$literalExpectation("false", false),
         function() { return { type: 'BooleanLiteral', value: false }; },
         "null",
         peg$literalExpectation("null", false),
         function() { return { type: 'NullLiteral' }; },
         function(literal) { return literal; },
         function(first, rest) { return buildList(first, rest, 2)},
         function(properties) { return { type: 'ObjectLiteral', properties: properties } },
         ":",
         peg$literalExpectation(":", false),
         function(key, value) { return { type: 'Property', key: key, value: value} },
         function(elements) { return { type: 'ArrayLiteral', elements: elements } },
         /^[lL]/,
         peg$classExpectation(["l", "L"], false, false),
         function() { return { type: 'NumberLiteral', value: text() }; },
         "0",
         peg$literalExpectation("0", false),
         /^[1-9]/,
         peg$classExpectation([["1", "9"]], false, false),
         /^[_]/,
         peg$classExpectation(["_"], false, false),
         "0x",
         peg$literalExpectation("0x", false),
         "0X",
         peg$literalExpectation("0X", false),
         "0b",
         peg$literalExpectation("0b", false),
         "0B",
         peg$literalExpectation("0B", false),
         /^[01]/,
         peg$classExpectation(["0", "1"], false, false),
         /^[0-7]/,
         peg$classExpectation([["0", "7"]], false, false),
         ".",
         peg$literalExpectation(".", false),
         /^[fFdD]/,
         peg$classExpectation(["f", "F", "d", "D"], false, false),
         /^[eE]/,
         peg$classExpectation(["e", "E"], false, false),
         /^[+\-]/,
         peg$classExpectation(["+", "-"], false, false),
         /^[pP]/,
         peg$classExpectation(["p", "P"], false, false),
         /^[a-f]/,
         peg$classExpectation([["a", "f"]], false, false),
         /^[A-F]/,
         peg$classExpectation([["A", "F"]], false, false),
         "'",
         peg$literalExpectation("'", false),
         /^['\\\n\r]/,
         peg$classExpectation(["'", "\\", "\n", "\r"], false, false),
         function(chars) { return { type: 'Literal', value: chars.map(l => l[0] == undefined ? l[1] : l[0] + l[1]).join('') } },
         "\"",
         peg$literalExpectation("\"", false),
         /^["\\\n\r]/,
         peg$classExpectation(["\"", "\\", "\n", "\r"], false, false),
         "\\",
         peg$literalExpectation("\\", false),
         /^[btnfr"'`\\]/,
         peg$classExpectation(["b", "t", "n", "f", "r", "\"", "'", "`", "\\"], false, false),
         /^[0-3]/,
         peg$classExpectation([["0", "3"]], false, false),
         "u",
         peg$literalExpectation("u", false),
         "=>",
         peg$literalExpectation("=>", true),
         "+",
         peg$literalExpectation("+", true),
         "&",
         peg$literalExpectation("&", true),
         "&&",
         peg$literalExpectation("&&", true),
         ",",
         peg$literalExpectation(",", false),
         "/",
         peg$literalExpectation("/", true),
         "==",
         peg$literalExpectation("==", true),
         "===",
         peg$literalExpectation("===", true),
         ">=",
         peg$literalExpectation(">=", true),
         ">",
         peg$literalExpectation(">", true),
         "-",
         peg$literalExpectation("-", false),
         "[",
         peg$literalExpectation("[", false),
         "{",
         peg$literalExpectation("{", false),
         "<=",
         peg$literalExpectation("<=", true),
         "(",
         peg$literalExpectation("(", false),
         "<",
         peg$literalExpectation("<", true),
         "<<",
         peg$literalExpectation("<<", true),
         ">>",
         peg$literalExpectation(">>", true),
         ">>>",
         peg$literalExpectation(">>>", true),
         "%",
         peg$literalExpectation("%", true),
         "!=",
         peg$literalExpectation("!=", true),
         "!==",
         peg$literalExpectation("!==", true),
         "!",
         peg$literalExpectation("!", true),
         "~",
         peg$literalExpectation("~", true),
         "|",
         peg$literalExpectation("|", true),
         "||",
         peg$literalExpectation("||", true),
         "^",
         peg$literalExpectation("^", true),
         peg$literalExpectation("+", false),
         "++",
         peg$literalExpectation("++", false),
         "--",
         peg$literalExpectation("--", false),
         "]",
         peg$literalExpectation("]", false),
         "}",
         peg$literalExpectation("}", false),
         ")",
         peg$literalExpectation(")", false),
         peg$literalExpectation("-", true),
         "*",
         peg$literalExpectation("*", true),
         "?",
         peg$literalExpectation("?", true)
       ],

       peg$bytecode = [
         peg$decode(";!"),
         peg$decode("%;7/M#;6/D$;S/;$;6/2$;\"/)$8%: %\"$ )(%'#($'#(#'#(\"'#&'#.\u0126 &%;c/^#;6/U$;v/L$;6/C$;S/:$;6/1$;\"/($8':!'! )(''#(&'#(%'#($'#(#'#(\"'#&'#.\xDB &%;c/\xCB#%;7/\x85#$%%;X/,#;6/#$+\")(\"'#&'#/,#;7/#$+\")(\"'#&'#0I*%%;X/,#;6/#$+\")(\"'#&'#/,#;7/#$+\")(\"'#&'#&/)$8\":\"\"\"! )(\"'#&'#/V$;v/M$;6/D$;S/;$;6/2$;\"/)$8':#'\"% )(''#(&'#(%'#($'#(#'#(\"'#&'#.# &;\""),
         peg$decode("%;#/r#;6/i$;y/`$;6/W$;\"/N$;6/E$;W/<$;6/3$;\"/*$8):$)#($ )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.# &;#"),
         peg$decode("%;$/\x85#$%%;o/,#;6/#$+\")(\"'#&'#/,#;$/#$+\")(\"'#&'#0I*%%;o/,#;6/#$+\")(\"'#&'#/,#;$/#$+\")(\"'#&'#&/)$8\":%\"\"! )(\"'#&'#"),
         peg$decode("%;%/\x85#$%%;V/,#;6/#$+\")(\"'#&'#/,#;%/#$+\")(\"'#&'#0I*%%;V/,#;6/#$+\")(\"'#&'#/,#;%/#$+\")(\"'#&'#&/)$8\":&\"\"! )(\"'#&'#"),
         peg$decode("%;&/\x85#$%%;n/,#;6/#$+\")(\"'#&'#/,#;&/#$+\")(\"'#&'#0I*%%;n/,#;6/#$+\")(\"'#&'#/,#;&/#$+\")(\"'#&'#&/)$8\":'\"\"! )(\"'#&'#"),
         peg$decode("%;'/\x85#$%%;p/,#;6/#$+\")(\"'#&'#/,#;'/#$+\")(\"'#&'#0I*%%;p/,#;6/#$+\")(\"'#&'#/,#;'/#$+\")(\"'#&'#&/)$8\":'\"\"! )(\"'#&'#"),
         peg$decode("%;(/\x85#$%%;U/,#;6/#$+\")(\"'#&'#/,#;(/#$+\")(\"'#&'#0I*%%;U/,#;6/#$+\")(\"'#&'#/,#;(/#$+\")(\"'#&'#&/)$8\":'\"\"! )(\"'#&'#"),
         peg$decode("%;)/\u011B#$%%;[/,#;6/#$+\")(\"'#&'#.h &%;\\/,#;6/#$+\")(\"'#&'#.O &%;j/,#;6/#$+\")(\"'#&'#.6 &%;k/,#;6/#$+\")(\"'#&'#/,#;)/#$+\")(\"'#&'#0\x94*%%;[/,#;6/#$+\")(\"'#&'#.h &%;\\/,#;6/#$+\")(\"'#&'#.O &%;j/,#;6/#$+\")(\"'#&'#.6 &%;k/,#;6/#$+\")(\"'#&'#/,#;)/#$+\")(\"'#&'#&/)$8\":(\"\"! )(\"'#&'#"),
         peg$decode("%;*/\u011B#$%%;b/,#;6/#$+\")(\"'#&'#.h &%;]/,#;6/#$+\")(\"'#&'#.O &%;d/,#;6/#$+\")(\"'#&'#.6 &%;^/,#;6/#$+\")(\"'#&'#/,#;*/#$+\")(\"'#&'#0\x94*%%;b/,#;6/#$+\")(\"'#&'#.h &%;]/,#;6/#$+\")(\"'#&'#.O &%;d/,#;6/#$+\")(\"'#&'#.6 &%;^/,#;6/#$+\")(\"'#&'#/,#;*/#$+\")(\"'#&'#&/)$8\":)\"\"! )(\"'#&'#"),
         peg$decode("%;+/\xE9#$%%;g/,#;6/#$+\")(\"'#&'#.O &%;e/,#;6/#$+\")(\"'#&'#.6 &%;f/,#;6/#$+\")(\"'#&'#/,#;+/#$+\")(\"'#&'#0{*%%;g/,#;6/#$+\")(\"'#&'#.O &%;e/,#;6/#$+\")(\"'#&'#.6 &%;f/,#;6/#$+\")(\"'#&'#/,#;+/#$+\")(\"'#&'#&/)$8\":*\"\"! )(\"'#&'#"),
         peg$decode("%;,/\xB7#$%%;T/,#;6/#$+\")(\"'#&'#.6 &%;w/,#;6/#$+\")(\"'#&'#/,#;,/#$+\")(\"'#&'#0b*%%;T/,#;6/#$+\")(\"'#&'#.6 &%;w/,#;6/#$+\")(\"'#&'#/,#;,/#$+\")(\"'#&'#&/)$8\":+\"\"! )(\"'#&'#"),
         peg$decode("%;-/\xE9#$%%;x/,#;6/#$+\")(\"'#&'#.O &%;Y/,#;6/#$+\")(\"'#&'#.6 &%;i/,#;6/#$+\")(\"'#&'#/,#;-/#$+\")(\"'#&'#0{*%%;x/,#;6/#$+\")(\"'#&'#.O &%;Y/,#;6/#$+\")(\"'#&'#.6 &%;i/,#;6/#$+\")(\"'#&'#/,#;-/#$+\")(\"'#&'#&/)$8\":+\"\"! )(\"'#&'#"),
         peg$decode("%;2/2#;./)$8\":,\"\"! )(\"'#&'#.# &;."),
         peg$decode("%;//F#;r.# &;s.\" &\"/2$;6/)$8#:-#\"\"!)(#'#(\"'#&'#"),
         peg$decode(";0./ &;1.) &;:.# &;<"),
         peg$decode("%;c/L#;6/C$;\"/:$;v/1$;6/($8%:.%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%%<;R=.##&&!&'#/;#;7/2$;3/)$8#:/#\"! )(#'#(\"'#&'#.\u010D &%%<;R=.##&&!&'#/e#;7.# &;</V$;`/M$;6/D$;\"/;$;t/2$;6/)$8':0'\"%\")(''#(&'#(%'#($'#(#'#(\"'#&'#.\xAF &%%<;R=.##&&!&'#/t#;7.) &;N.# &;:/_$$%;Z/,#;1/#$+\")(\"'#&'#06*%;Z/,#;1/#$+\")(\"'#&'#&/)$8#:1#\"! )(#'#(\"'#&'#.B &%%<;R=.##&&!&'#/,#;7/#$+\")(\"'#&'#"),
         peg$decode("%;l.\x9A &%;r/,#;6/#$+\")(\"'#&'#.\x81 &%;s/,#;6/#$+\")(\"'#&'#.h &%;q/,#;6/#$+\")(\"'#&'#.O &%;h/,#;6/#$+\")(\"'#&'#.6 &%;m/,#;6/#$+\")(\"'#&'#/' 8!:2!! )"),
         peg$decode("%;c/\xCF#;6/\xC6$%;!.# &;\"/\x91#$%%;X/,#;6/#$+\")(\"'#&'#/2#;!.# &;\"/#$+\")(\"'#&'#0O*%%;X/,#;6/#$+\")(\"'#&'#/2#;!.# &;\"/#$+\")(\"'#&'#&/)$8\":\"\"\"! )(\"'#&'#.\" &\"/:$;v/1$;6/($8%:3%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;`/>#;6/5$;t/,$;6/#$+$)($'#(#'#(\"'#&'#"),
         peg$decode("%;`/L#;6/C$;\"/:$;t/1$;6/($8%:4%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("$$45\"\"5!76/,#0)*45\"\"5!76&&&#0<*$45\"\"5!76/,#0)*45\"\"5!76&&&#&"),
         peg$decode("%;8/B#$;90#*;9&/2$;6/)$8#:7#\"\"!)(#'#(\"'#&'#"),
         peg$decode("48\"\"5!79.5 &4:\"\"5!7;.) &4<\"\"5!7="),
         peg$decode("48\"\"5!79.A &4:\"\"5!7;.5 &4>\"\"5!7?.) &4<\"\"5!7="),
         peg$decode("%2@\"\"6@7A/\u0287#$;;.\u013D &;O.\u0137 &%2B\"\"6B7C/L#%<4D\"\"5!7E=.##&&!&'#/1$1\"\"5!7F/#$+#)(#'#(\"'#&'#.\xF8 &%2G\"\"6G7H/L#%<4D\"\"5!7E=.##&&!&'#/1$1\"\"5!7F/#$+#)(#'#(\"'#&'#.\xB9 &%2I\"\"6I7J/1#1\"\"5!7F/#$+\")(\"'#&'#.\x95 &%2K\"\"6K7L/1#1\"\"5!7F/#$+\")(\"'#&'#.q &%2M\"\"6M7N/1#1\"\"5!7F/#$+\")(\"'#&'#.M &%%<4O\"\"5!7P=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#0\u0143*;;.\u013D &;O.\u0137 &%2B\"\"6B7C/L#%<4D\"\"5!7E=.##&&!&'#/1$1\"\"5!7F/#$+#)(#'#(\"'#&'#.\xF8 &%2G\"\"6G7H/L#%<4D\"\"5!7E=.##&&!&'#/1$1\"\"5!7F/#$+#)(#'#(\"'#&'#.\xB9 &%2I\"\"6I7J/1#1\"\"5!7F/#$+\")(\"'#&'#.\x95 &%2K\"\"6K7L/1#1\"\"5!7F/#$+\")(\"'#&'#.q &%2M\"\"6M7N/1#1\"\"5!7F/#$+\")(\"'#&'#.M &%%<4O\"\"5!7P=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#&/7$2@\"\"6@7A/($8#:Q#!!)(#'#(\"'#&'#"),
         peg$decode("%2G\"\"6G7H/L#;a/C$;6/:$;\"/1$;u/($8%:R%!!)(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;=.\xC2 &;E.\xBC &;@.\xB6 &;N.\xB0 &;?.\xAA &%2S\"\"6S7T/<#%<;9=.##&&!&'#/'$8\":U\" )(\"'#&'#.{ &%2V\"\"6V7W/<#%<;9=.##&&!&'#/'$8\":X\" )(\"'#&'#.L &%2Y\"\"6Y7Z/<#%<;9=.##&&!&'#/'$8\":[\" )(\"'#&'#/1#;6/($8\":\\\"!!)(\"'#&'#"),
         peg$decode("%;a/\xD3#;6/\xCA$%;>/q#$%;X/5#;6/,$;>/#$+#)(#'#(\"'#&'#0?*%;X/5#;6/,$;>/#$+#)(#'#(\"'#&'#&/)$8\":]\"\"! )(\"'#&'#.\" &\"/d$%;X/,#;6/#$+\")(\"'#&'#.\" &\"/C$;6/:$;u/1$;6/($8':^'!$)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;6/q#;7.) &;@.# &;N/\\$;6/S$2_\"\"6_7`/D$;6/;$;\"/2$;6/)$8':a'\"%!)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;`/\xD3#;6/\xCA$%;\"/q#$%;X/5#;6/,$;\"/#$+#)(#'#(\"'#&'#0?*%;X/5#;6/,$;\"/#$+#)(#'#(\"'#&'#&/)$8\":]\"\"! )(\"'#&'#.\" &\"/d$%;X/,#;6/#$+\")(\"'#&'#.\" &\"/C$;6/:$;t/1$;6/($8':b'!$)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;B./ &;C.) &;D.# &;A/;#4c\"\"5!7d.\" &\"/'$8\":e\" )(\"'#&'#"),
         peg$decode("2f\"\"6f7g.\x9B &%4h\"\"5!7i/\x8B#$%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4>\"\"5!7?/#$+\")(\"'#&'#0O*%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4>\"\"5!7?/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("%2l\"\"6l7m.) &2n\"\"6n7o/,#;L/#$+\")(\"'#&'#"),
         peg$decode("%2p\"\"6p7q.) &2r\"\"6r7s/\x9A#4t\"\"5!7u/\x8B$$%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4t\"\"5!7u/#$+\")(\"'#&'#0O*%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4t\"\"5!7u/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"),
         peg$decode("%2f\"\"6f7g/\x91#$%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4v\"\"5!7w/#$+\")(\"'#&'#/R#0O*%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4v\"\"5!7w/#$+\")(\"'#&'#&&&#/#$+\")(\"'#&'#"),
         peg$decode("%;H.# &;F/& 8!:e! )"),
         peg$decode("%;K/b#2x\"\"6x7y/S$;K.\" &\"/E$;G.\" &\"/7$4z\"\"5!7{.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#.\xB8 &%2x\"\"6x7y/N#;K/E$;G.\" &\"/7$4z\"\"5!7{.\" &\"/#$+$)($'#(#'#(\"'#&'#.w &%;K/@#;G/7$4z\"\"5!7{.\" &\"/#$+#)(#'#(\"'#&'#.J &%;K/@#;G.\" &\"/2$4z\"\"5!7{/#$+#)(#'#(\"'#&'#"),
         peg$decode("%4|\"\"5!7}/@#4~\"\"5!7\x7F.\" &\"/,$;K/#$+#)(#'#(\"'#&'#"),
         peg$decode("%;I/@#;J/7$4z\"\"5!7{.\" &\"/#$+#)(#'#(\"'#&'#"),
         peg$decode("%2l\"\"6l7m.) &2n\"\"6n7o/I#;L.\" &\"/;$2x\"\"6x7y/,$;L/#$+$)($'#(#'#(\"'#&'#.A &%;B/7#2x\"\"6x7y.\" &\"/#$+\")(\"'#&'#"),
         peg$decode("%4\x80\"\"5!7\x81/@#4~\"\"5!7\x7F.\" &\"/,$;K/#$+#)(#'#(\"'#&'#"),
         peg$decode("%4>\"\"5!7?/\x8B#$%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4>\"\"5!7?/#$+\")(\"'#&'#0O*%$4j\"\"5!7k0)*4j\"\"5!7k&/2#4>\"\"5!7?/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("%;M/\x7F#$%$4j\"\"5!7k0)*4j\"\"5!7k&/,#;M/#$+\")(\"'#&'#0I*%$4j\"\"5!7k0)*4j\"\"5!7k&/,#;M/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("4\x82\"\"5!7\x83.5 &4\x84\"\"5!7\x85.) &4>\"\"5!7?"),
         peg$decode("%2\x86\"\"6\x867\x87/\xA7#$;O.M &%%<4\x88\"\"5!7\x89=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#0S*;O.M &%%<4\x88\"\"5!7\x89=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#&/7$2\x86\"\"6\x867\x87/($8#:\x8A#!!)(#'#(\"'#&'#.\xB7 &%2\x8B\"\"6\x8B7\x8C/\xA7#$;O.M &%%<4\x8D\"\"5!7\x8E=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#0S*;O.M &%%<4\x8D\"\"5!7\x8E=.##&&!&'#/1#1\"\"5!7F/#$+\")(\"'#&'#&/7$2\x8B\"\"6\x8B7\x8C/($8#:\x8A#!!)(#'#(\"'#&'#"),
         peg$decode("%2\x8F\"\"6\x8F7\x90/>#4\x91\"\"5!7\x92.) &;P.# &;Q/#$+\")(\"'#&'#"),
         peg$decode("%4\x93\"\"5!7\x94/A#4v\"\"5!7w/2$4v\"\"5!7w/#$+#)(#'#(\"'#&'#.N &%4v\"\"5!7w/2#4v\"\"5!7w/#$+\")(\"'#&'#.) &4v\"\"5!7w"),
         peg$decode("%$2\x95\"\"6\x957\x96/,#0)*2\x95\"\"6\x957\x96&&&#/G#;M/>$;M/5$;M/,$;M/#$+%)(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%2S\"\"6S7T/8#%<;9=.##&&!&'#/#$+\")(\"'#&'#.s &%2V\"\"6V7W/8#%<;9=.##&&!&'#/#$+\")(\"'#&'#.H &%2Y\"\"6Y7Z/8#%<;9=.##&&!&'#/#$+\")(\"'#&'#"),
         peg$decode("3\x97\"\"5\"7\x98"),
         peg$decode("3\x99\"\"5!7\x9A"),
         peg$decode("3\x9B\"\"5!7\x9C"),
         peg$decode("3\x9D\"\"5\"7\x9E"),
         peg$decode("2_\"\"6_7`"),
         peg$decode("2\x9F\"\"6\x9F7\xA0"),
         peg$decode("3\xA1\"\"5!7\xA2"),
         peg$decode("2x\"\"6x7y"),
         peg$decode("3\xA3\"\"5\"7\xA4"),
         peg$decode("3\xA5\"\"5#7\xA6"),
         peg$decode("3\xA7\"\"5\"7\xA8"),
         peg$decode("3\xA9\"\"5!7\xAA"),
         peg$decode("2\xAB\"\"6\xAB7\xAC"),
         peg$decode("2\xAD\"\"6\xAD7\xAE"),
         peg$decode("2\xAF\"\"6\xAF7\xB0"),
         peg$decode("3\xB1\"\"5\"7\xB2"),
         peg$decode("2\xB3\"\"6\xB37\xB4"),
         peg$decode("3\xB5\"\"5!7\xB6"),
         peg$decode("3\xB7\"\"5\"7\xB8"),
         peg$decode("3\xB9\"\"5\"7\xBA"),
         peg$decode("3\xBB\"\"5#7\xBC"),
         peg$decode("2\xAB\"\"6\xAB7\xAC"),
         peg$decode("3\xBD\"\"5!7\xBE"),
         peg$decode("3\xBF\"\"5\"7\xC0"),
         peg$decode("3\xC1\"\"5#7\xC2"),
         peg$decode("3\xC3\"\"5!7\xC4"),
         peg$decode("3\xC5\"\"5!7\xC6"),
         peg$decode("3\xC7\"\"5!7\xC8"),
         peg$decode("3\xC9\"\"5\"7\xCA"),
         peg$decode("3\xCB\"\"5!7\xCC"),
         peg$decode("2\x99\"\"6\x997\xCD"),
         peg$decode("2\xCE\"\"6\xCE7\xCF"),
         peg$decode("2\xD0\"\"6\xD07\xD1"),
         peg$decode("2\xD2\"\"6\xD27\xD3"),
         peg$decode("2\xD4\"\"6\xD47\xD5"),
         peg$decode("2\xD6\"\"6\xD67\xD7"),
         peg$decode("3\xAB\"\"5!7\xD8"),
         peg$decode("3\xD9\"\"5!7\xDA"),
         peg$decode("3\xDB\"\"5!7\xDC")
       ],

       peg$currPos          = 0,
       peg$savedPos         = 0,
       peg$posDetailsCache  = [{ line: 1, column: 1 }],
       peg$maxFailPos       = 0,
       peg$maxFailExpected  = [],
       peg$silentFails      = 0,

       peg$resultsCache = {},

       peg$result;

   if ("startRule" in options) {
     if (!(options.startRule in peg$startRuleIndices)) {
       throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
     }

     peg$startRuleIndex = peg$startRuleIndices[options.startRule];
   }

   function text() {
     return input.substring(peg$savedPos, peg$currPos);
   }

   function location() {
     return peg$computeLocation(peg$savedPos, peg$currPos);
   }

   function expected(description, location) {
     location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

     throw peg$buildStructuredError(
       [peg$otherExpectation(description)],
       input.substring(peg$savedPos, peg$currPos),
       location
     );
   }

   function error(message, location) {
     location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

     throw peg$buildSimpleError(message, location);
   }

   function peg$literalExpectation(text, ignoreCase) {
     return { type: "literal", text: text, ignoreCase: ignoreCase };
   }

   function peg$classExpectation(parts, inverted, ignoreCase) {
     return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
   }

   function peg$anyExpectation() {
     return { type: "any" };
   }

   function peg$endExpectation() {
     return { type: "end" };
   }

   function peg$otherExpectation(description) {
     return { type: "other", description: description };
   }

   function peg$computePosDetails(pos) {
     var details = peg$posDetailsCache[pos], p;

     if (details) {
       return details;
     } else {
       p = pos - 1;
       while (!peg$posDetailsCache[p]) {
         p--;
       }

       details = peg$posDetailsCache[p];
       details = {
         line:   details.line,
         column: details.column
       };

       while (p < pos) {
         if (input.charCodeAt(p) === 10) {
           details.line++;
           details.column = 1;
         } else {
           details.column++;
         }

         p++;
       }

       peg$posDetailsCache[pos] = details;
       return details;
     }
   }

   function peg$computeLocation(startPos, endPos) {
     var startPosDetails = peg$computePosDetails(startPos),
         endPosDetails   = peg$computePosDetails(endPos);

     return {
       start: {
         offset: startPos,
         line:   startPosDetails.line,
         column: startPosDetails.column
       },
       end: {
         offset: endPos,
         line:   endPosDetails.line,
         column: endPosDetails.column
       }
     };
   }

   function peg$fail(expected) {
     if (peg$currPos < peg$maxFailPos) { return; }

     if (peg$currPos > peg$maxFailPos) {
       peg$maxFailPos = peg$currPos;
       peg$maxFailExpected = [];
     }

     peg$maxFailExpected.push(expected);
   }

   function peg$buildSimpleError(message, location) {
     return new peg$SyntaxError(message, null, null, location);
   }

   function peg$buildStructuredError(expected, found, location) {
     return new peg$SyntaxError(
       peg$SyntaxError.buildMessage(expected, found),
       expected,
       found,
       location
     );
   }

   function peg$decode(s) {
     var bc = new Array(s.length), i;

     for (i = 0; i < s.length; i++) {
       bc[i] = s.charCodeAt(i) - 32;
     }

     return bc;
   }

   function peg$parseRule(index) {
     var bc    = peg$bytecode[index],
         ip    = 0,
         ips   = [],
         end   = bc.length,
         ends  = [],
         stack = [],
         params, i;

     var key    = peg$currPos * 90 + index,
         cached = peg$resultsCache[key];

     if (cached) {
       peg$currPos = cached.nextPos;

       return cached.result;
     }

     while (true) {
       while (ip < end) {
         switch (bc[ip]) {
           case 0:
             stack.push(peg$consts[bc[ip + 1]]);
             ip += 2;
             break;

           case 1:
             stack.push(void 0);
             ip++;
             break;

           case 2:
             stack.push(null);
             ip++;
             break;

           case 3:
             stack.push(peg$FAILED);
             ip++;
             break;

           case 4:
             stack.push([]);
             ip++;
             break;

           case 5:
             stack.push(peg$currPos);
             ip++;
             break;

           case 6:
             stack.pop();
             ip++;
             break;

           case 7:
             peg$currPos = stack.pop();
             ip++;
             break;

           case 8:
             stack.length -= bc[ip + 1];
             ip += 2;
             break;

           case 9:
             stack.splice(-2, 1);
             ip++;
             break;

           case 10:
             stack[stack.length - 2].push(stack.pop());
             ip++;
             break;

           case 11:
             stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
             ip += 2;
             break;

           case 12:
             stack.push(input.substring(stack.pop(), peg$currPos));
             ip++;
             break;

           case 13:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1]) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 14:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1] === peg$FAILED) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 15:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1] !== peg$FAILED) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 16:
             if (stack[stack.length - 1] !== peg$FAILED) {
               ends.push(end);
               ips.push(ip);

               end = ip + 2 + bc[ip + 1];
               ip += 2;
             } else {
               ip += 2 + bc[ip + 1];
             }

             break;

           case 17:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (input.length > peg$currPos) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 18:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 19:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 20:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 21:
             stack.push(input.substr(peg$currPos, bc[ip + 1]));
             peg$currPos += bc[ip + 1];
             ip += 2;
             break;

           case 22:
             stack.push(peg$consts[bc[ip + 1]]);
             peg$currPos += peg$consts[bc[ip + 1]].length;
             ip += 2;
             break;

           case 23:
             stack.push(peg$FAILED);
             if (peg$silentFails === 0) {
               peg$fail(peg$consts[bc[ip + 1]]);
             }
             ip += 2;
             break;

           case 24:
             peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
             ip += 2;
             break;

           case 25:
             peg$savedPos = peg$currPos;
             ip++;
             break;

           case 26:
             params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
             for (i = 0; i < bc[ip + 3]; i++) {
               params[i] = stack[stack.length - 1 - params[i]];
             }

             stack.splice(
               stack.length - bc[ip + 2],
               bc[ip + 2],
               peg$consts[bc[ip + 1]].apply(null, params)
             );

             ip += 4 + bc[ip + 3];
             break;

           case 27:
             stack.push(peg$parseRule(bc[ip + 1]));
             ip += 2;
             break;

           case 28:
             peg$silentFails++;
             ip++;
             break;

           case 29:
             peg$silentFails--;
             ip++;
             break;

           default:
             throw new Error("Invalid opcode: " + bc[ip] + ".");
         }
       }

       if (ends.length > 0) {
         end = ends.pop();
         ip = ips.pop();
       } else {
         break;
       }
     }

     peg$resultsCache[key] = { nextPos: peg$currPos, result: stack[0] };

     return stack[0];
   }


     function buildList(first, rest, index) {
       var result = new Array(rest.length), i;

       for (i = 0; i < rest.length; i++) {
         result[i] = rest[i][index];
       }
       
       return [first].concat(result);
     }

     function buildTree(first, rest, builder) {
       var result = first, i;

       for (i = 0; i < rest.length; i++) {
         result = builder(result, rest[i]);
       }

       return result;
     }


   peg$result = peg$parseRule(peg$startRuleIndex);

   if (peg$result !== peg$FAILED && peg$currPos === input.length) {
     return peg$result;
   } else {
     if (peg$result !== peg$FAILED && peg$currPos < input.length) {
       peg$fail(peg$endExpectation());
     }

     throw peg$buildStructuredError(
       peg$maxFailExpected,
       peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
       peg$maxFailPos < input.length
         ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
         : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
     );
   }
 }

 return {
   SyntaxError: peg$SyntaxError,
   parse:       peg$parse
 };
})();

export default parser