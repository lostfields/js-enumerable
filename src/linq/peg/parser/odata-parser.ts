/* eslint-disable */
// @ts-nocheck 

let parser = /*
* Generated by PEG.js 0.10.0.
*
* http://pegjs.org/
*/
(function() {
 "use strict";

 function peg$subclass(child, parent) {
   function ctor() { this.constructor = child; }
   ctor.prototype = parent.prototype;
   child.prototype = new ctor();
 }

 function peg$SyntaxError(message, expected, found, location) {
   this.message  = message;
   this.expected = expected;
   this.found    = found;
   this.location = location;
   this.name     = "SyntaxError";

   if (typeof Error.captureStackTrace === "function") {
     Error.captureStackTrace(this, peg$SyntaxError);
   }
 }

 peg$subclass(peg$SyntaxError, Error);

 peg$SyntaxError.buildMessage = function(expected, found) {
   var DESCRIBE_EXPECTATION_FNS = {
         literal: function(expectation) {
           return "\"" + literalEscape(expectation.text) + "\"";
         },

         "class": function(expectation) {
           var escapedParts = "",
               i;

           for (i = 0; i < expectation.parts.length; i++) {
             escapedParts += expectation.parts[i] instanceof Array
               ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
               : classEscape(expectation.parts[i]);
           }

           return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
         },

         any: function(expectation) {
           return "any character";
         },

         end: function(expectation) {
           return "end of input";
         },

         other: function(expectation) {
           return expectation.description;
         }
       };

   function hex(ch) {
     return ch.charCodeAt(0).toString(16).toUpperCase();
   }

   function literalEscape(s) {
     return s
       .replace(/\\/g, '\\\\')
       .replace(/"/g,  '\\"')
       .replace(/\0/g, '\\0')
       .replace(/\t/g, '\\t')
       .replace(/\n/g, '\\n')
       .replace(/\r/g, '\\r')
       .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
       .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
   }

   function classEscape(s) {
     return s
       .replace(/\\/g, '\\\\')
       .replace(/\]/g, '\\]')
       .replace(/\^/g, '\\^')
       .replace(/-/g,  '\\-')
       .replace(/\0/g, '\\0')
       .replace(/\t/g, '\\t')
       .replace(/\n/g, '\\n')
       .replace(/\r/g, '\\r')
       .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
       .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
   }

   function describeExpectation(expectation) {
     return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
   }

   function describeExpected(expected) {
     var descriptions = new Array(expected.length),
         i, j;

     for (i = 0; i < expected.length; i++) {
       descriptions[i] = describeExpectation(expected[i]);
     }

     descriptions.sort();

     if (descriptions.length > 0) {
       for (i = 1, j = 1; i < descriptions.length; i++) {
         if (descriptions[i - 1] !== descriptions[i]) {
           descriptions[j] = descriptions[i];
           j++;
         }
       }
       descriptions.length = j;
     }

     switch (descriptions.length) {
       case 1:
         return descriptions[0];

       case 2:
         return descriptions[0] + " or " + descriptions[1];

       default:
         return descriptions.slice(0, -1).join(", ")
           + ", or "
           + descriptions[descriptions.length - 1];
     }
   }

   function describeFound(found) {
     return found ? "\"" + literalEscape(found) + "\"" : "end of input";
   }

   return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
 };

 function peg$parse(input, options?) {
   options = options !== void 0 ? options : {};

   var peg$FAILED = {},

       peg$startRuleIndices = { Start: 0 },
       peg$startRuleIndex   = 0,

       peg$consts = [
         function(args, expr) {
               return {
               type: 'LambdaExpression',
                     arguments: [args],
                     expression: expr
                 }
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'LogicalExpression',
                   operator: '||',
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 return {
                   type: 'LogicalExpression',
                   operator: '&&',
                   left: result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 let map = { 'eq': '==', 'ne': '!=' }
                 
                 return {
                   type: 'RelationalExpression',
                   operator: map[element[0][0].toLowerCase()],
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 let map = { 'le': '<=', 'ge': '>=', 'lt': '<', 'gt': '>' }
           
                 return {
                   type: 'RelationalExpression',
                   operator: map[element[0][0].toLowerCase()],
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 let map = { 'add': '+', 'sub': '-' }
               
                 return {
                   type: 'BinaryExpression',
                   operator: map[element[0][0].toLowerCase()],
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(first, rest) {
               return buildTree(first, rest, function(result, element) {
                 let map = { 'mul': '*', 'div': '/', 'mod': '%' }
                 
                 return {
                   type: 'BinaryExpression',
                   operator: map[element[0][0].toLowerCase()],
                   left:  result,
                   right: element[1]
                 };
               });
             },
         function(operator, operand) {
               return operand.type === 'NumberLiteral' && (operator === '-' || operator === '+')
                 ? 
                 { 
                   type: 'NumberLiteral', 
                   value: (operator === '-' ? operator : '') + operand.value
                 }
                 :
                 {
                   type: 'UnaryExpression', 
                   operator: operator, 
                   argument:  operand
                 };
             },
         function(expr) { return expr; },
         function(qual, args) { 
               return {
                 type: 'CallExpression', 
                 object: qual,
                 arguments: args
               };
             },
         function(qual, expr) { 
               return { 
               type: 'ArrayExpression', 
                 array: qual, 
                 index: expr 
               };
             },
         function(first, i) { return i; },
         function(first, list) { 
               if(list) {
                 return {
                   type: 'MemberExpression',
                   object: first,
                   property: list
                 }
               }
               return first;
             },
         function(op) { 
               let map = { 'not': '!', '+': '+', '-': '-' }
               return map[op[0].toLowerCase()]; 
             },
         function(first, rest) { return buildList(first, rest, 1); },
         function(args) { return args || []; },
         function(exp) { return exp; },
         /^[ \t\r\n\f]/,
         peg$classExpectation([" ", "\t", "\r", "\n", "\f"], false, false),
         function(first, last) { return { type: 'Identifier', name: first + last.join('') }; },
         /^[a-z]/,
         peg$classExpectation([["a", "z"]], false, false),
         /^[A-Z]/,
         peg$classExpectation([["A", "Z"]], false, false),
         /^[_$]/,
         peg$classExpectation(["_", "$"], false, false),
         /^[0-9]/,
         peg$classExpectation([["0", "9"]], false, false),
         "true",
         peg$literalExpectation("true", false),
         function() { return { type: 'BooleanLiteral', value: true }; },
         "false",
         peg$literalExpectation("false", false),
         function() { return { type: 'BooleanLiteral', value: false }; },
         "null",
         peg$literalExpectation("null", false),
         function() { return { type: 'NullLiteral' }; },
         function(literal) { return literal; },
         /^[lL]/,
         peg$classExpectation(["l", "L"], false, false),
         function() { return { type: 'NumberLiteral', value: text() }; },
         "0",
         peg$literalExpectation("0", false),
         /^[1-9]/,
         peg$classExpectation([["1", "9"]], false, false),
         /^[_]/,
         peg$classExpectation(["_"], false, false),
         "0x",
         peg$literalExpectation("0x", false),
         "0X",
         peg$literalExpectation("0X", false),
         "0b",
         peg$literalExpectation("0b", false),
         "0B",
         peg$literalExpectation("0B", false),
         /^[01]/,
         peg$classExpectation(["0", "1"], false, false),
         /^[0-7]/,
         peg$classExpectation([["0", "7"]], false, false),
         "-",
         peg$literalExpectation("-", false),
         "T",
         peg$literalExpectation("T", false),
         ":",
         peg$literalExpectation(":", false),
         ".",
         peg$literalExpectation(".", false),
         "Z",
         peg$literalExpectation("Z", false),
         function(value) { return { type: 'DateTimeLiteral', value: flattenArray(value).join('') }; },
         "datetime",
         peg$literalExpectation("datetime", true),
         "'",
         peg$literalExpectation("'", false),
         function(first, value, last) { return { type: 'DateTimeLiteral', value: flattenArray(value).join('') }; },
         function(value) { return { type: 'DateLiteral', value: flattenArray(value).join('') }; },
         "date",
         peg$literalExpectation("date", true),
         function(first, value, last) { return { type: 'DateLiteral', value: flattenArray(value).join('') }; },
         /^[fFdD]/,
         peg$classExpectation(["f", "F", "d", "D"], false, false),
         /^[eE]/,
         peg$classExpectation(["e", "E"], false, false),
         /^[+\-]/,
         peg$classExpectation(["+", "-"], false, false),
         /^[pP]/,
         peg$classExpectation(["p", "P"], false, false),
         /^[a-f]/,
         peg$classExpectation([["a", "f"]], false, false),
         /^[A-F]/,
         peg$classExpectation([["A", "F"]], false, false),
         /^['\\\n\r]/,
         peg$classExpectation(["'", "\\", "\n", "\r"], false, false),
         peg$anyExpectation(),
         function(chars) { return { type: 'Literal', value: chars.map(l => l[0] == undefined ? l[1] : l[0] + l[1]).join('').replace(/\\(["'\\])|'(')/g, '$1$2') } },
         "''",
         peg$literalExpectation("''", false),
         "\\",
         peg$literalExpectation("\\", false),
         /^[btnfr"'\\]/,
         peg$classExpectation(["b", "t", "n", "f", "r", "\"", "'", "\\"], false, false),
         /^[0-3]/,
         peg$classExpectation([["0", "3"]], false, false),
         "u",
         peg$literalExpectation("u", false),
         "add",
         peg$literalExpectation("add", true),
         "and",
         peg$literalExpectation("and", true),
         ",",
         peg$literalExpectation(",", false),
         "div",
         peg$literalExpectation("div", true),
         "/",
         peg$literalExpectation("/", false),
         "eq",
         peg$literalExpectation("eq", true),
         "ge",
         peg$literalExpectation("ge", true),
         "gt",
         peg$literalExpectation("gt", true),
         "[",
         peg$literalExpectation("[", false),
         "le",
         peg$literalExpectation("le", true),
         "(",
         peg$literalExpectation("(", false),
         "lt",
         peg$literalExpectation("lt", true),
         "mod",
         peg$literalExpectation("mod", true),
         "ne",
         peg$literalExpectation("ne", true),
         "not",
         peg$literalExpectation("not", true),
         "or",
         peg$literalExpectation("or", true),
         "+",
         peg$literalExpectation("+", false),
         "]",
         peg$literalExpectation("]", false),
         ")",
         peg$literalExpectation(")", false),
         "sub",
         peg$literalExpectation("sub", true),
         "mul",
         peg$literalExpectation("mul", true)
       ],

       peg$bytecode = [
         peg$decode(";\""),
         peg$decode("%;1/M#;0/D$;L/;$;0/2$;\"/)$8%: %\"$ )(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;#/\x85#$%%;\\/,#;0/#$+\")(\"'#&'#/,#;#/#$+\")(\"'#&'#0I*%%;\\/,#;0/#$+\")(\"'#&'#/,#;#/#$+\")(\"'#&'#&/)$8\":!\"\"! )(\"'#&'#"),
         peg$decode("%;$/\x85#$%%;K/,#;0/#$+\")(\"'#&'#/,#;$/#$+\")(\"'#&'#0I*%%;K/,#;0/#$+\")(\"'#&'#/,#;$/#$+\")(\"'#&'#&/)$8\":\"\"\"! )(\"'#&'#"),
         peg$decode("%;%/\xB7#$%%;P/,#;0/#$+\")(\"'#&'#.6 &%;Z/,#;0/#$+\")(\"'#&'#/,#;%/#$+\")(\"'#&'#0b*%%;P/,#;0/#$+\")(\"'#&'#.6 &%;Z/,#;0/#$+\")(\"'#&'#/,#;%/#$+\")(\"'#&'#&/)$8\":#\"\"! )(\"'#&'#"),
         peg$decode("%;&/\u011B#$%%;U/,#;0/#$+\")(\"'#&'#.h &%;Q/,#;0/#$+\")(\"'#&'#.O &%;W/,#;0/#$+\")(\"'#&'#.6 &%;R/,#;0/#$+\")(\"'#&'#/,#;&/#$+\")(\"'#&'#0\x94*%%;U/,#;0/#$+\")(\"'#&'#.h &%;Q/,#;0/#$+\")(\"'#&'#.O &%;W/,#;0/#$+\")(\"'#&'#.6 &%;R/,#;0/#$+\")(\"'#&'#/,#;&/#$+\")(\"'#&'#&/)$8\":$\"\"! )(\"'#&'#"),
         peg$decode("%;'/\xB7#$%%;J/,#;0/#$+\")(\"'#&'#.6 &%;`/,#;0/#$+\")(\"'#&'#/,#;'/#$+\")(\"'#&'#0b*%%;J/,#;0/#$+\")(\"'#&'#.6 &%;`/,#;0/#$+\")(\"'#&'#/,#;'/#$+\")(\"'#&'#&/)$8\":%\"\"! )(\"'#&'#"),
         peg$decode("%;(/\xE9#$%%;a/,#;0/#$+\")(\"'#&'#.O &%;N/,#;0/#$+\")(\"'#&'#.6 &%;Y/,#;0/#$+\")(\"'#&'#/,#;(/#$+\")(\"'#&'#0{*%%;a/,#;0/#$+\")(\"'#&'#.O &%;N/,#;0/#$+\")(\"'#&'#.6 &%;Y/,#;0/#$+\")(\"'#&'#/,#;(/#$+\")(\"'#&'#&/)$8\":&\"\"! )(\"'#&'#"),
         peg$decode("%;,/2#;)/)$8\":'\"\"! )(\"'#&'#.# &;)"),
         peg$decode(";*.5 &;:./ &;;.) &;+.# &;4"),
         peg$decode("%;V/L#;0/C$;\"/:$;_/1$;0/($8%:(%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%%<;I=.##&&!&'#/;#;1/2$;-/)$8#:)#\"! )(#'#(\"'#&'#.\xC7 &%%<;I=.##&&!&'#/_#;1/V$;T/M$;0/D$;\"/;$;^/2$;0/)$8':*'\"%\")(''#(&'#(%'#($'#(#'#(\"'#&'#.o &%%<;I=.##&&!&'#/Y#;1/P$%;O/2#;+/)$8\":+\"\"# )(\"'#&'#.\" &\"/)$8#:,#\"! )(#'#(\"'#&'#"),
         peg$decode("%%;[/,#;0/#$+\")(\"'#&'#.O &%;]/,#;0/#$+\")(\"'#&'#.6 &%;X/,#;0/#$+\")(\"'#&'#/' 8!:-!! )"),
         peg$decode("%;V/\xCF#;0/\xC6$%;!.# &;\"/\x91#$%%;M/,#;0/#$+\")(\"'#&'#/2#;!.# &;\"/#$+\")(\"'#&'#0O*%%;M/,#;0/#$+\")(\"'#&'#/2#;!.# &;\"/#$+\")(\"'#&'#&/)$8\":.\"\"! )(\"'#&'#.\" &\"/:$;_/1$;0/($8%:/%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;T/>#;0/5$;^/,$;0/#$+$)($'#(#'#(\"'#&'#"),
         peg$decode("%;T/L#;0/C$;\"/:$;^/1$;0/($8%:0%!\")(%'#($'#(#'#(\"'#&'#"),
         peg$decode("$$41\"\"5!72/,#0)*41\"\"5!72&&&#0<*$41\"\"5!72/,#0)*41\"\"5!72&&&#&"),
         peg$decode("%;2/B#$;30#*;3&/2$;0/)$8#:3#\"\"!)(#'#(\"'#&'#"),
         peg$decode("44\"\"5!75.5 &46\"\"5!77.) &48\"\"5!79"),
         peg$decode("44\"\"5!75.A &46\"\"5!77.5 &4:\"\"5!7;.) &48\"\"5!79"),
         peg$decode("%;<.\xB6 &;5.\xB0 &;E.\xAA &%2<\"\"6<7=/<#%<;3=.##&&!&'#/'$8\":>\" )(\"'#&'#.{ &%2?\"\"6?7@/<#%<;3=.##&&!&'#/'$8\":A\" )(\"'#&'#.L &%2B\"\"6B7C/<#%<;3=.##&&!&'#/'$8\":D\" )(\"'#&'#/1#;0/($8\":E\"!!)(\"'#&'#"),
         peg$decode("%;7./ &;8.) &;9.# &;6/;#4F\"\"5!7G.\" &\"/'$8\":H\" )(\"'#&'#"),
         peg$decode("2I\"\"6I7J.\x9B &%4K\"\"5!7L/\x8B#$%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4:\"\"5!7;/#$+\")(\"'#&'#0O*%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4:\"\"5!7;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("%2O\"\"6O7P.) &2Q\"\"6Q7R/,#;C/#$+\")(\"'#&'#"),
         peg$decode("%2S\"\"6S7T.) &2U\"\"6U7V/\x9A#4W\"\"5!7X/\x8B$$%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4W\"\"5!7X/#$+\")(\"'#&'#0O*%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4W\"\"5!7X/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"),
         peg$decode("%2I\"\"6I7J/\x91#$%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4Y\"\"5!7Z/#$+\")(\"'#&'#/R#0O*%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4Y\"\"5!7Z/#$+\")(\"'#&'#&&&#/#$+\")(\"'#&'#"),
         peg$decode("%%4:\"\"5!7;/\u0198#4:\"\"5!7;/\u0189$4:\"\"5!7;/\u017A$4:\"\"5!7;/\u016B$2[\"\"6[7\\/\u015C$4:\"\"5!7;/\u014D$4:\"\"5!7;/\u013E$2[\"\"6[7\\/\u012F$4:\"\"5!7;/\u0120$4:\"\"5!7;/\u0111$%2]\"\"6]7^/\xE4#4:\"\"5!7;/\xD5$4:\"\"5!7;/\xC6$2_\"\"6_7`/\xB7$4:\"\"5!7;/\xA8$4:\"\"5!7;/\x99$%2_\"\"6_7`/{#4:\"\"5!7;/l$4:\"\"5!7;/]$%2a\"\"6a7b/?#$4:\"\"5!7;0)*4:\"\"5!7;&/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#/7$2c\"\"6c7d.\" &\"/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/1#;0/($8\":e\"!!)(\"'#&'#.\u01F4 &%3f\"\"5(7g/\u01E4#2h\"\"6h7i/\u01D5$%4:\"\"5!7;/\u019D#4:\"\"5!7;/\u018E$4:\"\"5!7;/\u017F$4:\"\"5!7;/\u0170$2[\"\"6[7\\/\u0161$4:\"\"5!7;/\u0152$4:\"\"5!7;/\u0143$2[\"\"6[7\\/\u0134$4:\"\"5!7;/\u0125$4:\"\"5!7;/\u0116$%2]\"\"6]7^/\xE4#4:\"\"5!7;/\xD5$4:\"\"5!7;/\xC6$2_\"\"6_7`/\xB7$4:\"\"5!7;/\xA8$4:\"\"5!7;/\x99$%2_\"\"6_7`/{#4:\"\"5!7;/l$4:\"\"5!7;/]$%2a\"\"6a7b/?#$4:\"\"5!7;0)*4:\"\"5!7;&/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#.\" &\"/7$2c\"\"6c7d.\" &\"/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/B$2h\"\"6h7i/3$;0/*$8%:j%#$\"!)(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%%4:\"\"5!7;/\xBE#4:\"\"5!7;/\xAF$4:\"\"5!7;/\xA0$4:\"\"5!7;/\x91$2[\"\"6[7\\/\x82$4:\"\"5!7;/s$4:\"\"5!7;/d$2[\"\"6[7\\/U$4:\"\"5!7;/F$4:\"\"5!7;/7$2c\"\"6c7d.\" &\"/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/1#;0/($8\":k\"!!)(\"'#&'#.\u0115 &%3l\"\"5$7m/\u0105#2h\"\"6h7i/\xF6$%4:\"\"5!7;/\xBE#4:\"\"5!7;/\xAF$4:\"\"5!7;/\xA0$4:\"\"5!7;/\x91$2[\"\"6[7\\/\x82$4:\"\"5!7;/s$4:\"\"5!7;/d$2[\"\"6[7\\/U$4:\"\"5!7;/F$4:\"\"5!7;/7$2c\"\"6c7d.\" &\"/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/B$2h\"\"6h7i/3$;0/*$8%:n%#$\"!)(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%;?.# &;=/& 8!:H! )"),
         peg$decode("%;B/b#2a\"\"6a7b/S$;B.\" &\"/E$;>.\" &\"/7$4o\"\"5!7p.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#.\xB8 &%2a\"\"6a7b/N#;B/E$;>.\" &\"/7$4o\"\"5!7p.\" &\"/#$+$)($'#(#'#(\"'#&'#.w &%;B/@#;>/7$4o\"\"5!7p.\" &\"/#$+#)(#'#(\"'#&'#.J &%;B/@#;>.\" &\"/2$4o\"\"5!7p/#$+#)(#'#(\"'#&'#"),
         peg$decode("%4q\"\"5!7r/@#4s\"\"5!7t.\" &\"/,$;B/#$+#)(#'#(\"'#&'#"),
         peg$decode("%;@/@#;A/7$4o\"\"5!7p.\" &\"/#$+#)(#'#(\"'#&'#"),
         peg$decode("%2O\"\"6O7P.) &2Q\"\"6Q7R/I#;C.\" &\"/;$2a\"\"6a7b/,$;C/#$+$)($'#(#'#(\"'#&'#.A &%;7/7#2a\"\"6a7b.\" &\"/#$+\")(\"'#&'#"),
         peg$decode("%4u\"\"5!7v/@#4s\"\"5!7t.\" &\"/,$;B/#$+#)(#'#(\"'#&'#"),
         peg$decode("%4:\"\"5!7;/\x8B#$%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4:\"\"5!7;/#$+\")(\"'#&'#0O*%$4M\"\"5!7N0)*4M\"\"5!7N&/2#4:\"\"5!7;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("%;D/\x7F#$%$4M\"\"5!7N0)*4M\"\"5!7N&/,#;D/#$+\")(\"'#&'#0I*%$4M\"\"5!7N0)*4M\"\"5!7N&/,#;D/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
         peg$decode("4w\"\"5!7x.5 &4y\"\"5!7z.) &4:\"\"5!7;"),
         peg$decode("%2h\"\"6h7i/\xA7#$;F.M &%%<4{\"\"5!7|=.##&&!&'#/1#1\"\"5!7}/#$+\")(\"'#&'#0S*;F.M &%%<4{\"\"5!7|=.##&&!&'#/1#1\"\"5!7}/#$+\")(\"'#&'#&/7$2h\"\"6h7i/($8#:~#!!)(#'#(\"'#&'#"),
         peg$decode("2\x7F\"\"6\x7F7\x80.N &%2\x81\"\"6\x817\x82/>#4\x83\"\"5!7\x84.) &;G.# &;H/#$+\")(\"'#&'#"),
         peg$decode("%4\x85\"\"5!7\x86/A#4Y\"\"5!7Z/2$4Y\"\"5!7Z/#$+#)(#'#(\"'#&'#.N &%4Y\"\"5!7Z/2#4Y\"\"5!7Z/#$+\")(\"'#&'#.) &4Y\"\"5!7Z"),
         peg$decode("%$2\x87\"\"6\x877\x88/,#0)*2\x87\"\"6\x877\x88&&&#/G#;D/>$;D/5$;D/,$;D/#$+%)(%'#($'#(#'#(\"'#&'#"),
         peg$decode("%2<\"\"6<7=/8#%<;3=.##&&!&'#/#$+\")(\"'#&'#.s &%2?\"\"6?7@/8#%<;3=.##&&!&'#/#$+\")(\"'#&'#.H &%2B\"\"6B7C/8#%<;3=.##&&!&'#/#$+\")(\"'#&'#"),
         peg$decode("3\x89\"\"5#7\x8A"),
         peg$decode("3\x8B\"\"5#7\x8C"),
         peg$decode("2_\"\"6_7`"),
         peg$decode("2\x8D\"\"6\x8D7\x8E"),
         peg$decode("3\x8F\"\"5#7\x90"),
         peg$decode("2\x91\"\"6\x917\x92"),
         peg$decode("3\x93\"\"5\"7\x94"),
         peg$decode("3\x95\"\"5\"7\x96"),
         peg$decode("3\x97\"\"5\"7\x98"),
         peg$decode("2[\"\"6[7\\"),
         peg$decode("2\x99\"\"6\x997\x9A"),
         peg$decode("3\x9B\"\"5\"7\x9C"),
         peg$decode("2\x9D\"\"6\x9D7\x9E"),
         peg$decode("3\x9F\"\"5\"7\xA0"),
         peg$decode("2[\"\"6[7\\"),
         peg$decode("3\xA1\"\"5#7\xA2"),
         peg$decode("3\xA3\"\"5\"7\xA4"),
         peg$decode("3\xA5\"\"5#7\xA6"),
         peg$decode("3\xA7\"\"5\"7\xA8"),
         peg$decode("2\xA9\"\"6\xA97\xAA"),
         peg$decode("2\xAB\"\"6\xAB7\xAC"),
         peg$decode("2\xAD\"\"6\xAD7\xAE"),
         peg$decode("3\xAF\"\"5#7\xB0"),
         peg$decode("3\xB1\"\"5#7\xB2")
       ],

       peg$currPos          = 0,
       peg$savedPos         = 0,
       peg$posDetailsCache  = [{ line: 1, column: 1 }],
       peg$maxFailPos       = 0,
       peg$maxFailExpected  = [],
       peg$silentFails      = 0,

       peg$result;

   if ("startRule" in options) {
     if (!(options.startRule in peg$startRuleIndices)) {
       throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
     }

     peg$startRuleIndex = peg$startRuleIndices[options.startRule];
   }

   function text() {
     return input.substring(peg$savedPos, peg$currPos);
   }

   function location() {
     return peg$computeLocation(peg$savedPos, peg$currPos);
   }

   function expected(description, location) {
     location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

     throw peg$buildStructuredError(
       [peg$otherExpectation(description)],
       input.substring(peg$savedPos, peg$currPos),
       location
     );
   }

   function error(message, location) {
     location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

     throw peg$buildSimpleError(message, location);
   }

   function peg$literalExpectation(text, ignoreCase) {
     return { type: "literal", text: text, ignoreCase: ignoreCase };
   }

   function peg$classExpectation(parts, inverted, ignoreCase) {
     return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
   }

   function peg$anyExpectation() {
     return { type: "any" };
   }

   function peg$endExpectation() {
     return { type: "end" };
   }

   function peg$otherExpectation(description) {
     return { type: "other", description: description };
   }

   function peg$computePosDetails(pos) {
     var details = peg$posDetailsCache[pos], p;

     if (details) {
       return details;
     } else {
       p = pos - 1;
       while (!peg$posDetailsCache[p]) {
         p--;
       }

       details = peg$posDetailsCache[p];
       details = {
         line:   details.line,
         column: details.column
       };

       while (p < pos) {
         if (input.charCodeAt(p) === 10) {
           details.line++;
           details.column = 1;
         } else {
           details.column++;
         }

         p++;
       }

       peg$posDetailsCache[pos] = details;
       return details;
     }
   }

   function peg$computeLocation(startPos, endPos) {
     var startPosDetails = peg$computePosDetails(startPos),
         endPosDetails   = peg$computePosDetails(endPos);

     return {
       start: {
         offset: startPos,
         line:   startPosDetails.line,
         column: startPosDetails.column
       },
       end: {
         offset: endPos,
         line:   endPosDetails.line,
         column: endPosDetails.column
       }
     };
   }

   function peg$fail(expected) {
     if (peg$currPos < peg$maxFailPos) { return; }

     if (peg$currPos > peg$maxFailPos) {
       peg$maxFailPos = peg$currPos;
       peg$maxFailExpected = [];
     }

     peg$maxFailExpected.push(expected);
   }

   function peg$buildSimpleError(message, location) {
     return new peg$SyntaxError(message, null, null, location);
   }

   function peg$buildStructuredError(expected, found, location) {
     return new peg$SyntaxError(
       peg$SyntaxError.buildMessage(expected, found),
       expected,
       found,
       location
     );
   }

   function peg$decode(s) {
     var bc = new Array(s.length), i;

     for (i = 0; i < s.length; i++) {
       bc[i] = s.charCodeAt(i) - 32;
     }

     return bc;
   }

   function peg$parseRule(index) {
     var bc    = peg$bytecode[index],
         ip    = 0,
         ips   = [],
         end   = bc.length,
         ends  = [],
         stack = [],
         params, i;

     while (true) {
       while (ip < end) {
         switch (bc[ip]) {
           case 0:
             stack.push(peg$consts[bc[ip + 1]]);
             ip += 2;
             break;

           case 1:
             stack.push(void 0);
             ip++;
             break;

           case 2:
             stack.push(null);
             ip++;
             break;

           case 3:
             stack.push(peg$FAILED);
             ip++;
             break;

           case 4:
             stack.push([]);
             ip++;
             break;

           case 5:
             stack.push(peg$currPos);
             ip++;
             break;

           case 6:
             stack.pop();
             ip++;
             break;

           case 7:
             peg$currPos = stack.pop();
             ip++;
             break;

           case 8:
             stack.length -= bc[ip + 1];
             ip += 2;
             break;

           case 9:
             stack.splice(-2, 1);
             ip++;
             break;

           case 10:
             stack[stack.length - 2].push(stack.pop());
             ip++;
             break;

           case 11:
             stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
             ip += 2;
             break;

           case 12:
             stack.push(input.substring(stack.pop(), peg$currPos));
             ip++;
             break;

           case 13:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1]) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 14:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1] === peg$FAILED) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 15:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (stack[stack.length - 1] !== peg$FAILED) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 16:
             if (stack[stack.length - 1] !== peg$FAILED) {
               ends.push(end);
               ips.push(ip);

               end = ip + 2 + bc[ip + 1];
               ip += 2;
             } else {
               ip += 2 + bc[ip + 1];
             }

             break;

           case 17:
             ends.push(end);
             ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

             if (input.length > peg$currPos) {
               end = ip + 3 + bc[ip + 1];
               ip += 3;
             } else {
               end = ip + 3 + bc[ip + 1] + bc[ip + 2];
               ip += 3 + bc[ip + 1];
             }

             break;

           case 18:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 19:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 20:
             ends.push(end);
             ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

             if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
               end = ip + 4 + bc[ip + 2];
               ip += 4;
             } else {
               end = ip + 4 + bc[ip + 2] + bc[ip + 3];
               ip += 4 + bc[ip + 2];
             }

             break;

           case 21:
             stack.push(input.substr(peg$currPos, bc[ip + 1]));
             peg$currPos += bc[ip + 1];
             ip += 2;
             break;

           case 22:
             stack.push(peg$consts[bc[ip + 1]]);
             peg$currPos += peg$consts[bc[ip + 1]].length;
             ip += 2;
             break;

           case 23:
             stack.push(peg$FAILED);
             if (peg$silentFails === 0) {
               peg$fail(peg$consts[bc[ip + 1]]);
             }
             ip += 2;
             break;

           case 24:
             peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
             ip += 2;
             break;

           case 25:
             peg$savedPos = peg$currPos;
             ip++;
             break;

           case 26:
             params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
             for (i = 0; i < bc[ip + 3]; i++) {
               params[i] = stack[stack.length - 1 - params[i]];
             }

             stack.splice(
               stack.length - bc[ip + 2],
               bc[ip + 2],
               peg$consts[bc[ip + 1]].apply(null, params)
             );

             ip += 4 + bc[ip + 3];
             break;

           case 27:
             stack.push(peg$parseRule(bc[ip + 1]));
             ip += 2;
             break;

           case 28:
             peg$silentFails++;
             ip++;
             break;

           case 29:
             peg$silentFails--;
             ip++;
             break;

           default:
             throw new Error("Invalid opcode: " + bc[ip] + ".");
         }
       }

       if (ends.length > 0) {
         end = ends.pop();
         ip = ips.pop();
       } else {
         break;
       }
     }

     return stack[0];
   }


     function buildList(first, rest, index) {
       var result = new Array(rest.length), i;

       for (i = 0; i < rest.length; i++) {
         result[i] = rest[i][index];
       }
       
       return [first].concat(result);
     }

     function buildTree(first, rest, builder) {
       var result = first, i;

       for (i = 0; i < rest.length; i++) {
         result = builder(result, rest[i]);
       }

       return result;
     }
     
     function flattenArray(value) {
       return Array.isArray(value) ? [].concat.apply([], value.map(function(v) { return flattenArray(v) })) : value
     }


   peg$result = peg$parseRule(peg$startRuleIndex);

   if (peg$result !== peg$FAILED && peg$currPos === input.length) {
     return peg$result;
   } else {
     if (peg$result !== peg$FAILED && peg$currPos < input.length) {
       peg$fail(peg$endExpectation());
     }

     throw peg$buildStructuredError(
       peg$maxFailExpected,
       peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
       peg$maxFailPos < input.length
         ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
         : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
     );
   }
 }

 return {
   SyntaxError: peg$SyntaxError,
   parse:       peg$parse
 };
})();

export default parser